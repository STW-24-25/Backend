AWSTemplateFormatVersion: '2010-09-09'
Description: 'CloudFormation template for a Node.js containerized backend with GitHub Actions integration, MongoDB Atlas, and HTTPS support'
Parameters:
  EnvironmentName:
    Description: Name of the environment
    Type: String
    Default: nodejsdevenvironment

  VpcCIDR:
    Description: CIDR block for the VPC
    Type: String
    Default: 10.0.0.0/16

  PublicSubnet1CIDR:
    Description: CIDR block for the first public subnet
    Type: String
    Default: 10.0.1.0/24

  PublicSubnet2CIDR:
    Description: CIDR block for the second public subnet
    Type: String
    Default: 10.0.2.0/24

  KeyPairName:
    Description: Name of an existing EC2 key pair for SSH access
    Type: AWS::EC2::KeyPair::KeyName

  AllowedCIDR:
    Description: CIDR block allowed for SSH access
    Type: String
    Default: 0.0.0.0/0

  NodeJsVersion:
    Description: Node.js version to install
    Type: String
    Default: '22.14'
    AllowedValues:
    - '16'
    - '18'
    - '20'
    - '22.14'

  GitHubRepoName:
    Description: GitHub repository name (format username/repository)
    Type: String
    Default: STW-24-25/Backend

  GitHubBranch:
    Description: GitHub branch to monitor for deployments
    Type: String
    Default: main

  LatestAmiId:
    Description: "Latest Amazon Linux 2 AMI"
    Type: 'String'
    Default: 'ami-0274f4b62b6ae3bd5'

  DomainName:
    Description: "Domain name for HTTPS (e.g., example.com)"
    Type: String
    Default: ""

  Email:
    Description: "Email for Let's Encrypt certificate notifications"
    Type: String
    Default: ""

Resources:
  # VPC Configuration
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: !Ref VpcCIDR
      EnableDnsHostnames: true
      EnableDnsSupport: true
      Tags:
      - Key: Name
        Value: !Sub ${EnvironmentName}-VPC

  # Internet Gateway
  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
      - Key: Name
        Value: !Sub ${EnvironmentName}-IGW

  InternetGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId: !Ref InternetGateway
      VpcId: !Ref VPC

  # Public Subnets for High Availability
  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [ 0, !GetAZs '' ]
      CidrBlock: !Ref PublicSubnet1CIDR
      MapPublicIpOnLaunch: true
      Tags:
      - Key: Name
        Value: !Sub ${EnvironmentName}-PublicSubnet1

  PublicSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [ 1, !GetAZs '' ]
      CidrBlock: !Ref PublicSubnet2CIDR
      MapPublicIpOnLaunch: true
      Tags:
      - Key: Name
        Value: !Sub ${EnvironmentName}-PublicSubnet2

  # Route Tables
  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
      - Key: Name
        Value: !Sub ${EnvironmentName}-PublicRouteTable

  DefaultPublicRoute:
    Type: AWS::EC2::Route
    DependsOn: InternetGatewayAttachment
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  PublicSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicRouteTable
      SubnetId: !Ref PublicSubnet1

  PublicSubnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicRouteTable
      SubnetId: !Ref PublicSubnet2

  # VPC Security Groups
  EC2SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for Node.js development server
      VpcId: !Ref VPC
      SecurityGroupIngress:
      - IpProtocol: tcp
        FromPort: 22
        ToPort: 22
        CidrIp: !Ref AllowedCIDR
      - IpProtocol: tcp
        FromPort: 80
        ToPort: 80
        CidrIp: 0.0.0.0/0
      - IpProtocol: tcp
        FromPort: 443
        ToPort: 443
        CidrIp: 0.0.0.0/0
      Tags:
      - Key: Name
        Value: !Sub ${EnvironmentName}-EC2-SG

  # ECR Repository
  ContainerRepository:
    Type: AWS::ECR::Repository
    Properties:
      RepositoryName: !Sub ${EnvironmentName}-repo
      ImageScanningConfiguration:
        ScanOnPush: true
      ImageTagMutability: MUTABLE
      EncryptionConfiguration:
        EncryptionType: AES256
      LifecyclePolicy:
        LifecyclePolicyText: |
          {
            "rules": [
              {
                "rulePriority": 1,
                "description": "Keep only the last 10 images",
                "selection": {
                  "tagStatus": "any",
                  "countType": "imageCountMoreThan",
                  "countNumber": 10
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }

  # GitHub OIDC Provider
  GitHubOIDCProvider:
    Type: AWS::IAM::OIDCProvider
    Properties:
      Url: https://token.actions.githubusercontent.com
      ClientIdList:
        - sts.amazonaws.com
      ThumbprintList:
        - 6938fd4d98bab03faadb97b34396831e3780aea1
      Tags:
        - Key: Name
          Value: !Sub ${EnvironmentName}-GitHubOIDCProvider

  # IAM Resources for GitHub Actions
  GitHubActionsRole:
    Type: AWS::IAM::Role
    DependsOn: GitHubOIDCProvider
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Federated: !Sub 'arn:aws:iam::${AWS::AccountId}:oidc-provider/token.actions.githubusercontent.com'
          Action: sts:AssumeRoleWithWebIdentity
          Condition:
            StringEquals:
              'token.actions.githubusercontent.com:aud': 'sts.amazonaws.com'
            StringLike:
              'token.actions.githubusercontent.com:sub': !Sub 'repo:${GitHubRepoName}:ref:refs/heads/main'
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryFullAccess
      Tags:
      - Key: Name
        Value: !Sub ${EnvironmentName}-GitHubActionsRole

  # IAM Resources for EC2
  EC2Role:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: ec2.amazonaws.com
          Action: sts:AssumeRole
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy
      - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly
      Policies:
      - PolicyName: S3Access
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - s3:GetObject
            - s3:PutObject
            - s3:ListBucket
            Resource:
            - !Sub arn:aws:s3:::${ArtifactBucket}
            - !Sub arn:aws:s3:::${ArtifactBucket}/*
      Tags:
      - Key: Name
        Value: !Sub ${EnvironmentName}-EC2Role

  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
      - !Ref EC2Role

  # S3 Bucket for Artifacts and Backups
  ArtifactBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub ${EnvironmentName}-artifacts-${AWS::AccountId}-${AWS::Region}
      AccessControl: Private
      VersioningConfiguration:
        Status: Enabled
      BucketEncryption:
        ServerSideEncryptionConfiguration:
        - ServerSideEncryptionByDefault:
            SSEAlgorithm: AES256
      LifecycleConfiguration:
        Rules:
        - Id: TransitionToIA
          Status: Enabled
          Transitions:
          - TransitionInDays: 30
            StorageClass: STANDARD_IA

  # EC2 Instance for Node.js Development (Free Tier eligible)
  NodeJsInstance:
    Type: AWS::EC2::Instance
    CreationPolicy:
      ResourceSignal:
        Timeout: PT15M
    Properties:
      InstanceType: t3.micro
      SecurityGroupIds:
      - !Ref EC2SecurityGroup
      KeyName: !Ref KeyPairName
      ImageId: !Ref LatestAmiId
      SubnetId: !Ref PublicSubnet1
      IamInstanceProfile: !Ref EC2InstanceProfile
      BlockDeviceMappings:
      - DeviceName: /dev/xvda
        Ebs:
          VolumeSize: 8
          VolumeType: gp2
          DeleteOnTermination: true
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash -xe

          # Update system packages
          yum update -y

          # Install required components
          yum install -y amazon-cloudwatch-agent docker nginx certbot python3-certbot-nginx

          # Configure and start Docker
          systemctl enable docker
          systemctl start docker
          usermod -a -G docker ec2-user

          # Login to ECR using instance role credentials
          aws ecr get-login-password --region ${AWS::Region} | docker login --username AWS --password-stdin ${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com

          # Create container management script that only pulls new images when needed
          cat > /home/ec2-user/update-container.sh << 'EOF'
          #!/bin/bash
          
          # Set repository and tag
          REPO="${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${ContainerRepository}"
          TAG="latest"
          FULL_IMAGE_NAME="$REPO:$TAG"
          
          # Login to ECR (token expires after 12 hours)
          aws ecr get-login-password --region ${AWS::Region} | docker login --username AWS --password-stdin $REPO
          
          # Get the current image digest if we have it locally
          CURRENT_DIGEST=""
          if docker image inspect $FULL_IMAGE_NAME &>/dev/null; then
            CURRENT_DIGEST=$(docker image inspect $FULL_IMAGE_NAME --format='{{index .RepoDigests 0}}' | cut -d'@' -f2)
          fi
          
          # Check if repository exists and has images
          if ! aws ecr describe-repositories --repository-names ${ContainerRepository} &>/dev/null; then
            echo "Repository ${ContainerRepository} does not exist yet. Waiting for first deployment."
            exit 0
          fi
          
          # Get the latest image digest from ECR (safely)
          LATEST_DIGEST=$(aws ecr describe-images --repository-name ${ContainerRepository} --image-ids imageTag=$TAG --query 'imageDetails[0].imageDigest' --output text 2>/dev/null || echo "")
          
          # Check if we got a valid digest
          if [ -z "$LATEST_DIGEST" ] || [ "$LATEST_DIGEST" == "None" ]; then
            echo "No images found with tag $TAG in repository. Waiting for first deployment."
            exit 0
          fi
          
          # Only pull if the image doesn't exist locally or there's a new version
          if [ -z "$CURRENT_DIGEST" ] || [ "$CURRENT_DIGEST" != "$LATEST_DIGEST" ]; then
            echo "New image detected. Pulling latest version..."
            if docker pull $FULL_IMAGE_NAME; then
              # Stop and remove existing container
              docker stop nodejs-app 2>/dev/null || true
              docker rm nodejs-app 2>/dev/null || true
              
              # Run new container with essential configurations
              docker run -d \
                --name nodejs-app \
                -p 5000:5000 \
                --restart unless-stopped \
                $FULL_IMAGE_NAME
                
              echo "Container updated successfully with new image."
              
              # Reload Nginx to ensure it picks up the new container
              systemctl reload nginx
            else
              echo "Failed to pull image. Check ECR permissions and connectivity."
            fi
          else
            echo "Container is already running the latest image. No update needed."
          fi
          EOF
          
          # Make script executable
          chmod +x /home/ec2-user/update-container.sh
          
          # Configure Nginx as reverse proxy (initially only HTTP)
          cat > /etc/nginx/conf.d/nodejs-app.conf << 'EOF'
          server {
              listen 80;
              server_name ${DomainName};
              
              location / {
                  proxy_pass http://localhost:5000;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade $http_upgrade;
                  proxy_set_header Connection 'upgrade';
                  proxy_set_header Host $host;
                  proxy_cache_bypass $http_upgrade;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
              }
          }
          EOF
          
          # Start and enable Nginx
          systemctl start nginx
          systemctl enable nginx
          
          # Run the container update script once to start the container initially
          /home/ec2-user/update-container.sh
          
          # Create a cron job to check for updates every hour
          echo "0 * * * * /home/ec2-user/update-container.sh >> /home/ec2-user/container-updates.log 2>&1" | crontab -
          
          # Set up SSL with Let's Encrypt if domain name is provided
          if [ ! -z "${DomainName}" ] && [ ! -z "${Email}" ]; then
            # Start Nginx first (required for Certbot)
            systemctl start nginx
            
            # Wait a bit to ensure DNS propagation (if newly configured)
            sleep 30
            
            # Try to get Let's Encrypt certificate
            if certbot --nginx -d ${DomainName} --non-interactive --agree-tos -m ${Email} --redirect; then
              echo "Let's Encrypt certificate obtained successfully"
              
              # Add cron job for certificate renewal
              echo "0 3 * * * certbot renew --quiet" | tee -a /var/spool/cron/root
            else
              echo "Let's Encrypt certificate failed, creating self-signed certificate"
              
              # Create directory for certificates if it doesn't exist
              sudo mkdir -p /etc/nginx/ssl/
              sudo chmod 700 /etc/nginx/ssl/
              
              # Generate self-signed certificate
              sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
                -keyout /etc/nginx/ssl/nginx-selfsigned.key \
                -out /etc/nginx/ssl/nginx-selfsigned.crt \
                -subj "/C=ES/ST=Aragon/L=Zaragoza/O=AgroNET/CN=${DomainName}"
              
              # Set proper permissions
              sudo chmod 600 /etc/nginx/ssl/nginx-selfsigned.key
              sudo chmod 644 /etc/nginx/ssl/nginx-selfsigned.crt
              sudo chown nginx:nginx /etc/nginx/ssl/nginx-selfsigned.*
              
              # Configure Nginx with self-signed certificate
              cat > /etc/nginx/conf.d/nodejs-app.conf << 'EOF'
              server {
                  listen 80;
                  server_name ${DomainName};
                  return 301 https://$host$request_uri;
              }
              
              server {
                  listen 443 ssl;
                  server_name ${DomainName};
                  
                  ssl_certificate /etc/nginx/ssl/nginx-selfsigned.crt;
                  ssl_certificate_key /etc/nginx/ssl/nginx-selfsigned.key;
                  
                  ssl_protocols TLSv1.2 TLSv1.3;
                  
                  location / {
                      proxy_pass http://localhost:5000;
                      proxy_http_version 1.1;
                      proxy_set_header Upgrade $http_upgrade;
                      proxy_set_header Connection 'upgrade';
                      proxy_set_header Host $host;
                      proxy_cache_bypass $http_upgrade;
                      proxy_set_header X-Real-IP $remote_addr;
                      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                      proxy_set_header X-Forwarded-Proto $scheme;
                  }
              }
              EOF
              
              # Reload Nginx with the new configuration
              systemctl reload nginx
            fi
          else
            # If no domain provided, just start Nginx with HTTP
            systemctl start nginx
          fi
          
          # Enable Nginx to start on boot
          systemctl enable nginx

          # Signal CloudFormation
          /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource NodeJsInstance --region ${AWS::Region}
      Tags:
      - Key: Name
        Value: !Sub ${EnvironmentName}-NodeJsInstance
      - Key: Environment
        Value: Development

Outputs:
  VPC:
    Description: VPC ID
    Value: !Ref VPC
    Export:
      Name: !Sub ${AWS::StackName}-VPC
  PublicSubnets:
    Description: List of Public Subnets
    Value: !Join [ ",", [ !Ref PublicSubnet1, !Ref PublicSubnet2 ] ]
    Export:
      Name: !Sub ${AWS::StackName}-PublicSubnets
  NodeJsInstancePublicIP:
    Description: Public IP address of the Node.js instance
    Value: !GetAtt NodeJsInstance.PublicIp
    Export:
      Name: !Sub ${AWS::StackName}-NodeJsIP
  NodeJsInstancePublicDNS:
    Description: Public DNS of the Node.js instance
    Value: !GetAtt NodeJsInstance.PublicDnsName
    Export:
      Name: !Sub ${AWS::StackName}-NodeJsDNS
  SSHCommand:
    Description: SSH command to connect to the instance
    Value: !Sub ssh -i ${KeyPairName}.pem ec2-user@${NodeJsInstance.PublicDnsName}
  ArtifactBucketName:
    Description: S3 Bucket for artifacts and backups
    Value: !Ref ArtifactBucket
    Export:
      Name: !Sub ${AWS::StackName}-ArtifactBucket
  ECRRepositoryURL:
    Description: ECR Repository URL
    Value: !Sub ${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${ContainerRepository}
    Export:
      Name: !Sub ${AWS::StackName}-ECRRepository
  GitHubActionsRoleARN:
    Description: IAM Role ARN for GitHub Actions
    Value: !GetAtt GitHubActionsRole.Arn
    Export:
      Name: !Sub ${AWS::StackName}-GitHubActionsRole
  WebsiteURL:
    Description: URL to access the website
    Value: !If [HasDomainName, !Sub "https://${DomainName}", !Sub "http://${NodeJsInstance.PublicDnsName}"]
    Export:
      Name: !Sub ${AWS::StackName}-WebsiteURL

Conditions:
  HasDomainName: !Not [!Equals [!Ref DomainName, ""]]
