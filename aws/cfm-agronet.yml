AWSTemplateFormatVersion: '2010-09-09'
Description: 'CloudFormation template for a Node.js containerized backend with GitHub Actions integration, MongoDB Atlas, and HTTPS support'
Parameters:
  EnvironmentName:
    Description: Name of the environment
    Type: String
    Default: nodejsdevenvironment

  VpcCIDR:
    Description: CIDR block for the VPC
    Type: String
    Default: 10.0.0.0/16

  PublicSubnet1CIDR:
    Description: CIDR block for the first public subnet
    Type: String
    Default: 10.0.1.0/24

  PublicSubnet2CIDR:
    Description: CIDR block for the second public subnet
    Type: String
    Default: 10.0.2.0/24

  KeyPairName:
    Description: Name of an existing EC2 key pair for SSH access
    Type: AWS::EC2::KeyPair::KeyName

  AllowedCIDR:
    Description: CIDR block allowed for SSH access
    Type: String
    Default: 0.0.0.0/0

  NodeJsVersion:
    Description: Node.js version to install
    Type: String
    Default: '22.14'
    AllowedValues:
    - '16'
    - '18'
    - '20'
    - '22.14'

  GitHubRepoName:
    Description: GitHub repository name (format username/repository)
    Type: String
    Default: STW-24-25/Backend

  GitHubBranch:
    Description: GitHub branch to monitor for deployments
    Type: String
    Default: main

  LatestAmiId:
    Description: "Latest Amazon Linux 2 AMI"
    Type: 'String'
    Default: 'ami-0274f4b62b6ae3bd5'

Resources:
  # VPC Configuration
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: !Ref VpcCIDR
      EnableDnsHostnames: true
      EnableDnsSupport: true
      Tags:
      - Key: Name
        Value: !Sub ${EnvironmentName}-VPC

  # Internet Gateway
  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
      - Key: Name
        Value: !Sub ${EnvironmentName}-IGW

  InternetGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId: !Ref InternetGateway
      VpcId: !Ref VPC

  # Public Subnets for High Availability
  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [ 0, !GetAZs '' ]
      CidrBlock: !Ref PublicSubnet1CIDR
      MapPublicIpOnLaunch: true
      Tags:
      - Key: Name
        Value: !Sub ${EnvironmentName}-PublicSubnet1

  PublicSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [ 1, !GetAZs '' ]
      CidrBlock: !Ref PublicSubnet2CIDR
      MapPublicIpOnLaunch: true
      Tags:
      - Key: Name
        Value: !Sub ${EnvironmentName}-PublicSubnet2

  # Route Tables
  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
      - Key: Name
        Value: !Sub ${EnvironmentName}-PublicRouteTable

  DefaultPublicRoute:
    Type: AWS::EC2::Route
    DependsOn: InternetGatewayAttachment
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  PublicSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicRouteTable
      SubnetId: !Ref PublicSubnet1

  PublicSubnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicRouteTable
      SubnetId: !Ref PublicSubnet2

  # VPC Security Groups
  EC2SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for Node.js development server
      VpcId: !Ref VPC
      SecurityGroupIngress:
      - IpProtocol: tcp
        FromPort: 22
        ToPort: 22
        CidrIp: !Ref AllowedCIDR
      - IpProtocol: tcp
        FromPort: 80
        ToPort: 80
        CidrIp: 0.0.0.0/0
      - IpProtocol: tcp
        FromPort: 443
        ToPort: 443
        CidrIp: 0.0.0.0/0
      Tags:
      - Key: Name
        Value: !Sub ${EnvironmentName}-EC2-SG

  # ECR Repository
  ContainerRepository:
    Type: AWS::ECR::Repository
    Properties:
      RepositoryName: !Sub ${EnvironmentName}-repo
      ImageScanningConfiguration:
        ScanOnPush: true
      ImageTagMutability: MUTABLE
      EncryptionConfiguration:
        EncryptionType: AES256
      LifecyclePolicy:
        LifecyclePolicyText: |
          {
            "rules": [
              {
                "rulePriority": 1,
                "description": "Keep only the last 10 images",
                "selection": {
                  "tagStatus": "any",
                  "countType": "imageCountMoreThan",
                  "countNumber": 10
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }

  # GitHub OIDC Provider
  GitHubOIDCProvider:
    Type: AWS::IAM::OIDCProvider
    Properties:
      Url: https://token.actions.githubusercontent.com
      ClientIdList:
        - sts.amazonaws.com
      ThumbprintList:
        - 6938fd4d98bab03faadb97b34396831e3780aea1
      Tags:
        - Key: Name
          Value: !Sub ${EnvironmentName}-GitHubOIDCProvider

  # IAM Resources for GitHub Actions
  GitHubActionsRole:
    Type: AWS::IAM::Role
    DependsOn: GitHubOIDCProvider
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Federated: !Sub 'arn:aws:iam::${AWS::AccountId}:oidc-provider/token.actions.githubusercontent.com'
          Action: sts:AssumeRoleWithWebIdentity
          Condition:
            StringEquals:
              'token.actions.githubusercontent.com:aud': 'sts.amazonaws.com'
            StringLike:
              'token.actions.githubusercontent.com:sub': !Sub 'repo:${GitHubRepoName}:ref:refs/heads/main'
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryFullAccess
      Tags:
      - Key: Name
        Value: !Sub ${EnvironmentName}-GitHubActionsRole

  # IAM Resources for EC2
  EC2Role:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: ec2.amazonaws.com
          Action: sts:AssumeRole
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy
      - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly
      Policies:
      - PolicyName: S3Access
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - s3:GetObject
            - s3:PutObject
            - s3:ListBucket
            Resource:
            - !Sub arn:aws:s3:::${ArtifactBucket}
            - !Sub arn:aws:s3:::${ArtifactBucket}/*
      Tags:
      - Key: Name
        Value: !Sub ${EnvironmentName}-EC2Role

  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
      - !Ref EC2Role

  # S3 Bucket for Artifacts and Backups
  ArtifactBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub ${EnvironmentName}-artifacts-${AWS::AccountId}-${AWS::Region}
      AccessControl: Private
      VersioningConfiguration:
        Status: Enabled
      BucketEncryption:
        ServerSideEncryptionConfiguration:
        - ServerSideEncryptionByDefault:
            SSEAlgorithm: AES256
      LifecycleConfiguration:
        Rules:
        - Id: TransitionToIA
          Status: Enabled
          Transitions:
          - TransitionInDays: 30
            StorageClass: STANDARD_IA

  # EC2 Instance for Node.js Development (Free Tier eligible)
  NodeJsInstance:
    Type: AWS::EC2::Instance
    CreationPolicy:
      ResourceSignal:
        Timeout: PT15M
    Properties:
      InstanceType: t3.micro
      SecurityGroupIds:
      - !Ref EC2SecurityGroup
      KeyName: !Ref KeyPairName
      ImageId: !Ref LatestAmiId
      SubnetId: !Ref PublicSubnet1
      IamInstanceProfile: !Ref EC2InstanceProfile
      BlockDeviceMappings:
      - DeviceName: /dev/xvda
        Ebs:
          VolumeSize: 8
          VolumeType: gp2
          DeleteOnTermination: true
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash -xe

          # Update system packages
          yum update -y

          # Install required components
          yum install -y amazon-cloudwatch-agent docker certbot jq cronie

          # Configure and start Docker
          systemctl enable docker
          systemctl start docker
          usermod -a -G docker ec2-user

          # Login to ECR using instance role credentials
          aws ecr get-login-password --region ${AWS::Region} | docker login --username AWS --password-stdin ${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com

          # Get instance metadata (including public IP)
          TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
          INSTANCE_PUBLIC_IP=$(curl -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/public-ipv4)
          
          # Create domains using nip.io for dynamic IP
          PRIMARY_DOMAIN="$INSTANCE_PUBLIC_IP.nip.io"
          SECONDARY_DOMAIN="agronetdev.$INSTANCE_PUBLIC_IP.nip.io"
          
          # Create directories for SSL certificates
          mkdir -p /etc/ssl/agronet
          
          # Create container management script that only pulls new images when needed
          cat > /home/ec2-user/update-container.sh << 'EOF'
          #!/bin/bash
          
          # Set repository and tag
          REPO="${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${ContainerRepository}"
          TAG="latest"
          FULL_IMAGE_NAME="$REPO:$TAG"
          
          # Get instance metadata (for dynamic IP)
          TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
          INSTANCE_PUBLIC_IP=$(curl -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/public-ipv4)
          
          # Create domains using nip.io
          PRIMARY_DOMAIN="$INSTANCE_PUBLIC_IP.nip.io"
          SECONDARY_DOMAIN="agronetdev.$INSTANCE_PUBLIC_IP.nip.io"
          
          # Login to ECR (token expires after 12 hours)
          aws ecr get-login-password --region ${AWS::Region} | docker login --username AWS --password-stdin $REPO
          
          # Check SSL certificates and renew if needed
          SSL_KEY_PATH="/etc/letsencrypt/live/$PRIMARY_DOMAIN/privkey.pem"
          SSL_CERT_PATH="/etc/letsencrypt/live/$PRIMARY_DOMAIN/fullchain.pem"
          
          # Check if certificates exist and are valid
          if [ ! -f "$SSL_KEY_PATH" ] || [ ! -f "$SSL_CERT_PATH" ]; then
            echo "SSL certificates not found. Requesting new certificates..."
            # Temporalmente detener cualquier contenedor que pueda estar usando el puerto 80
            docker stop nodejs-app 2>/dev/null || true
            
            # Obtener certificados
            certbot certonly --standalone --non-interactive --agree-tos -m admin@example.com \
              -d "$PRIMARY_DOMAIN" -d "$SECONDARY_DOMAIN" --cert-name "$PRIMARY_DOMAIN"
            
            # Create symbolic links to certificates for easier access
            mkdir -p /etc/ssl/agronet
            ln -sf $SSL_KEY_PATH /etc/ssl/agronet/server.key
            ln -sf $SSL_CERT_PATH /etc/ssl/agronet/server.crt
          fi
          
          # Get the current image digest if we have it locally
          CURRENT_DIGEST=""
          if docker image inspect $FULL_IMAGE_NAME &>/dev/null; then
            CURRENT_DIGEST=$(docker image inspect $FULL_IMAGE_NAME --format='{{index .RepoDigests 0}}' | cut -d'@' -f2)
          fi
          
          # Check if repository exists and has images
          if ! aws ecr describe-repositories --repository-names ${ContainerRepository} &>/dev/null; then
            echo "Repository ${ContainerRepository} does not exist yet. Waiting for first deployment."
            exit 0
          fi
          
          # Get the latest image digest from ECR (safely)
          LATEST_DIGEST=$(aws ecr describe-images --repository-name ${ContainerRepository} --image-ids imageTag=$TAG --query 'imageDetails[0].imageDigest' --output text 2>/dev/null || echo "")
          
          # Check if we got a valid digest
          if [ -z "$LATEST_DIGEST" ] || [ "$LATEST_DIGEST" == "None" ]; then
            echo "No images found with tag $TAG in repository. Waiting for first deployment."
            exit 0
          fi
          
          # Only pull if the image doesn't exist locally or there's a new version
          if [ -z "$CURRENT_DIGEST" ] || [ "$CURRENT_DIGEST" != "$LATEST_DIGEST" ]; then
            echo "New image detected. Pulling latest version..."
            if docker pull $FULL_IMAGE_NAME; then
              # Stop and remove existing container
              docker stop nodejs-app 2>/dev/null || true
              docker rm nodejs-app 2>/dev/null || true
              
              # Run new container mapping directly to host ports 80 y 443
              docker run -d \
                --name nodejs-app \
                -p 80:80 \
                -p 443:443 \
                -e SSL_KEY_PATH="/etc/ssl/agronet/server.key" \
                -e SSL_CERT_PATH="/etc/ssl/agronet/server.crt" \
                -e PORT=80 \
                -e HTTPS_PORT=443 \
                -v /etc/ssl/agronet:/etc/ssl/agronet:ro \
                --restart unless-stopped \
                $FULL_IMAGE_NAME
                
              # Verificar que los certificados sean accesibles desde el contenedor
              echo "Verificando acceso a los certificados desde el contenedor..."
              docker exec nodejs-app ls -la /etc/ssl/agronet/ || echo "¡Error! No se puede acceder a los certificados"
              
              echo "Container updated successfully with new image."
            else
              echo "Failed to pull image. Check ECR permissions and connectivity."
            fi
          else
            echo "Container is already running the latest image. No update needed."
          fi
          EOF
          
          # Make script executable
          chmod +x /home/ec2-user/update-container.sh
          
          # Obtener los certificados iniciales
          # Get instance metadata (for dynamic IP)
          TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
          INSTANCE_PUBLIC_IP=$(curl -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/public-ipv4)
          
          # Create domains using nip.io
          PRIMARY_DOMAIN="$INSTANCE_PUBLIC_IP.nip.io"
          SECONDARY_DOMAIN="agronetdev.$INSTANCE_PUBLIC_IP.nip.io"
          
          # Request certificates from Let's Encrypt
          certbot certonly --standalone --non-interactive --agree-tos -m 848481@unizar.es \
            -d "$PRIMARY_DOMAIN" -d "$SECONDARY_DOMAIN" --cert-name "$PRIMARY_DOMAIN"
          
          # Create symbolic links to certificates for easier access
          mkdir -p /etc/ssl/agronet
          ln -sf /etc/letsencrypt/live/$PRIMARY_DOMAIN/privkey.pem /etc/ssl/agronet/server.key
          ln -sf /etc/letsencrypt/live/$PRIMARY_DOMAIN/fullchain.pem /etc/ssl/agronet/server.crt
          
          # Asegurar que los permisos sean correctos
          chmod 644 /etc/ssl/agronet/server.crt
          chmod 600 /etc/ssl/agronet/server.key
          # Permitir que el usuario dentro del contenedor pueda leer los archivos
          setfacl -R -m u:1000:r /etc/ssl/agronet/
          
          # No ejecutamos update-container.sh inmediatamente
          # En su lugar, configuramos un cron job para que verifique periódicamente si hay imágenes en ECR
          echo "0 * * * * /home/ec2-user/update-container.sh >> /home/ec2-user/container-updates.log 2>&1" | crontab -
          
          # Mensaje informativo para el usuario
          echo "La instancia EC2 está configurada. Los certificados SSL se han generado correctamente." > /home/ec2-user/setup-complete.txt
          echo "El contenedor se iniciará automáticamente cuando se detecte una imagen en ECR (GitHub Actions)." >> /home/ec2-user/setup-complete.txt
          echo "Puedes verificar el estado ejecutando: cat /home/ec2-user/container-updates.log" >> /home/ec2-user/setup-complete.txt
          
          # Create renewal hook for certbot to update symbolic links
          mkdir -p /etc/letsencrypt/renewal-hooks/post/
          cat > /etc/letsencrypt/renewal-hooks/post/update-symlinks.sh << 'EOF'
          #!/bin/bash
          
          # Get instance metadata
          TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
          INSTANCE_PUBLIC_IP=$(curl -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/public-ipv4)
          PRIMARY_DOMAIN="$INSTANCE_PUBLIC_IP.nip.io"
          
          # Update symbolic links
          ln -sf /etc/letsencrypt/live/$PRIMARY_DOMAIN/privkey.pem /etc/ssl/agronet/server.key
          ln -sf /etc/letsencrypt/live/$PRIMARY_DOMAIN/fullchain.pem /etc/ssl/agronet/server.crt
          
          # Restart container to pick up new certificates
          docker restart nodejs-app
          EOF
          
          chmod +x /etc/letsencrypt/renewal-hooks/post/update-symlinks.sh
          
          # Add cron job for certificate renewal
          echo "0 3 * * * certbot renew --quiet" | tee -a /var/spool/cron/root

          # Signal CloudFormation
          /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource NodeJsInstance --region ${AWS::Region}

      Tags:
      - Key: Name
        Value: !Sub ${EnvironmentName}-NodeJsInstance
      - Key: Environment
        Value: Development

Outputs:
  VPC:
    Description: VPC ID
    Value: !Ref VPC
    Export:
      Name: !Sub ${AWS::StackName}-VPC
  PublicSubnets:
    Description: List of Public Subnets
    Value: !Join [ ",", [ !Ref PublicSubnet1, !Ref PublicSubnet2 ] ]
    Export:
      Name: !Sub ${AWS::StackName}-PublicSubnets
  NodeJsInstancePublicIP:
    Description: Public IP address of the Node.js instance
    Value: !GetAtt NodeJsInstance.PublicIp
    Export:
      Name: !Sub ${AWS::StackName}-NodeJsIP
  NodeJsInstancePublicDNS:
    Description: Public DNS of the Node.js instance
    Value: !GetAtt NodeJsInstance.PublicDnsName
    Export:
      Name: !Sub ${AWS::StackName}-NodeJsDNS
  SSHCommand:
    Description: SSH command to connect to the instance
    Value: !Sub ssh -i ${KeyPairName}.pem ec2-user@${NodeJsInstance.PublicDnsName}
  ArtifactBucketName:
    Description: S3 Bucket for artifacts and backups
    Value: !Ref ArtifactBucket
    Export:
      Name: !Sub ${AWS::StackName}-ArtifactBucket
  ECRRepositoryURL:
    Description: ECR Repository URL
    Value: !Sub ${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${ContainerRepository}
    Export:
      Name: !Sub ${AWS::StackName}-ECRRepository
  GitHubActionsRoleARN:
    Description: IAM Role ARN for GitHub Actions
    Value: !GetAtt GitHubActionsRole.Arn
    Export:
      Name: !Sub ${AWS::StackName}-GitHubActionsRole
  WebsiteURL:
    Description: URLs to access the website
    Value: !Sub |
      La aplicación estará disponible en:
      HTTP: http://${NodeJsInstance.PublicIp}.nip.io
      HTTPS: https://${NodeJsInstance.PublicIp}.nip.io
      Alternativo: https://agronetdev.${NodeJsInstance.PublicIp}.nip.io
    Export:
      Name: !Sub ${AWS::StackName}-WebsiteURL
