AWSTemplateFormatVersion: '2010-09-09'
Description: 'Configuración de recursos de cómputo para Frontend - AgroNet 2025'

Parameters:
  EnvironmentName:
    Description: Nombre del entorno
    Type: String
    Default: prod

  FrontendInstanceType:
    Description: Tipo de instancia EC2 para Frontend
    Type: String
    Default: t3.small
    AllowedValues:
      - t3.small
      - t3.medium
      - t3.large

  KeyName:
    Description: Nombre del Key Pair de EC2 para acceso SSH
    Type: AWS::EC2::KeyPair::KeyName

  LatestAmiId:
    Description: AMI para instancias de Frontend (Amazon Linux 2023)
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ami-amazon-linux-latest/al2023-ami-kernel-6.1-x86_64
    
  GitHubToken:
    Description: GitHub fine-grained personal access token para acceder a repositorios
    Type: String
    Default: "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"
    NoEcho: true

Resources:
  # IAM Role para permitir a las instancias obtener acceso a S3/ECR
  FrontendInstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
        - arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess
      Policies:
        - PolicyName: !Sub ${EnvironmentName}-frontend-instance-policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                  - secretsmanager:GetSecretValue
                  - ssm:GetParameter
                  - ssm:GetParameters
                  - ssm:GetParametersByPath
                Resource: '*'

  FrontendInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref FrontendInstanceRole

  # Launch Template para instancias de Frontend
  FrontendLaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateName: !Sub ${EnvironmentName}-frontend-launch-template
      VersionDescription: Initial version
      LaunchTemplateData:
        ImageId: !Ref LatestAmiId
        InstanceType: !Ref FrontendInstanceType
        KeyName: !Ref KeyName
        SecurityGroupIds:
          - !ImportValue 
            Fn::Sub: "${EnvironmentName}-Frontend-SecurityGroup"
        IamInstanceProfile:
          Name: !Ref FrontendInstanceProfile
        UserData:
          Fn::Base64: !Sub |
            #!/bin/bash -xe
            # Configuración para Amazon Linux 2023
            # Esperar a tener conexión con los repositorios antes de continuar
            attempts=0
            max_attempts=5
            
            until dnf list installed &> /dev/null || [ $attempts -eq $max_attempts ]
            do
              echo "Intento $((attempts+1))/$max_attempts para conectar con repositorios..."
              sleep 10
              attempts=$((attempts+1))
            done
            
            if [ $attempts -eq $max_attempts ]; then
              echo "No se pudo conectar con los repositorios. Continuando con la instalación sin actualizar."
            else
              dnf update -y
            fi
            
            # Instalar dependencias necesarias
            dnf install -y git nodejs npm jq aws-cli libcap

            # Permitir que Node.js se vincule a puertos privilegiados sin ser root
            setcap 'cap_net_bind_service=+ep' $(which node)
            
            # Instalar PM2 globalmente para gestionar el proceso
            npm install -g pm2
            
            # Obtener el token de GitHub desde Secrets Manager
            GITHUB_TOKEN=$(aws secretsmanager get-secret-value \
              --secret-id ${EnvironmentName}-github-token \
              --region ${AWS::Region} \
              --query SecretString --output text)

            # Configurar credenciales de Git para clonar repositorio
            echo "Configurando credenciales de Git..."
            export HOME=/home/ec2-user
            git config --global credential.helper store
            echo "https://oauth2:$GITHUB_TOKEN@github.com" > /home/ec2-user/.git-credentials
            chown ec2-user:ec2-user /home/ec2-user/.git-credentials
            chmod 600 /home/ec2-user/.git-credentials

            # Instalar dependencias y configurar
            cd /home/ec2-user
            echo "Clonando repositorio con token..."
            # Usar autenticación con token para clonar el repositorio
            sudo -u ec2-user git clone https://oauth2:$GITHUB_TOKEN@github.com/STW-24-25/Frontend.git
            cd Frontend
            sudo -u ec2-user npm install

            # Variable de instancia que será sustituida para cada instancia específica
            INSTANCE_ID=$(curl -s http://169.254.169.254/latest/meta-data/instance-id)
            
            # Configurar PM2 para iniciar con el sistema y ejecutar como ec2-user
            pm2 startup -u ec2-user
            env PATH=$PATH:/usr/bin pm2 startup systemd -u ec2-user --hp /home/ec2-user
            
            # Crear un script para ver los logs fácilmente
            cat > /usr/local/bin/check-frontend-logs << 'EOL'
              #!/bin/bash
              # Script para facilitar la revisión de logs
              echo "===== PM2 Status ====="
              su - ec2-user -c "pm2 status"
              echo ""
              echo "===== Frontend Logs ====="
              echo "Últimas 50 líneas del log de salida:"
              tail -n 50 /home/ec2-user/.pm2/logs/frontend-out.log
              echo ""
              echo "Últimas 50 líneas del log de error:"
              tail -n 50 /home/ec2-user/.pm2/logs/frontend-error.log
            EOL
            chmod +x /usr/local/bin/check-frontend-logs
            
            # Limpieza de credenciales
            rm /home/ec2-user/.git-credentials
        TagSpecifications:
          - ResourceType: instance
            Tags:
              - Key: Name
                Value: !Sub ${EnvironmentName}-Frontend-Instance
              - Key: Environment
                Value: !Ref EnvironmentName

  # Frontend Instances en cada zona de disponibilidad
  FrontendInstance1:
    Type: AWS::EC2::Instance
    Properties:
      LaunchTemplate:
        LaunchTemplateId: !Ref FrontendLaunchTemplate
        Version: !GetAtt FrontendLaunchTemplate.LatestVersionNumber
      SubnetId: !ImportValue 
        Fn::Sub: "${EnvironmentName}-Frontend-Public-Subnet-1-ID"
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash -xe
          # Configurar variables de entorno específicas para instancia 1
          cd /home/ec2-user/Frontend
          
          # Obtener el DNS del NLB1 desde SSM Parameter Store
          NLB1_DNS=$(aws ssm get-parameter --name /${EnvironmentName}/network/nlb1-dns --region ${AWS::Region} --query "Parameter.Value" --output text)
          
          cat > .env << EOL
          PUBLIC_API_URL=http://$NLB1_DNS:80/api/
          PORT=4321
          EOL
          
          # Construir la aplicación
          sudo -u ec2-user npm run build
          
          # Iniciar con PM2 como usuario ec2-user
          sudo -u ec2-user pm2 start npm --name "frontend" -- run start
          sudo -u ec2-user pm2 save
      Tags:
        - Key: Name
          Value: !Sub ${EnvironmentName}-Frontend-Instance-1

  FrontendInstance2:
    Type: AWS::EC2::Instance
    Properties:
      LaunchTemplate:
        LaunchTemplateId: !Ref FrontendLaunchTemplate
        Version: !GetAtt FrontendLaunchTemplate.LatestVersionNumber
      SubnetId: !ImportValue 
        Fn::Sub: "${EnvironmentName}-Frontend-Public-Subnet-2-ID"
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash -xe
          # Configurar variables de entorno específicas para instancia 2
          cd /home/ec2-user/Frontend
          
          # Obtener el DNS del NLB2 desde SSM Parameter Store
          NLB2_DNS=$(aws ssm get-parameter --name /${EnvironmentName}/network/nlb2-dns --region ${AWS::Region} --query "Parameter.Value" --output text)
          
          cat > .env << EOL
          PUBLIC_API_URL=http://$NLB2_DNS:80/api/
          PORT=4321
          EOL
          
          # Construir la aplicación
          sudo -u ec2-user npm run build
          
          # Iniciar con PM2 como usuario ec2-user
          sudo -u ec2-user pm2 start npm --name "frontend" -- run start
          sudo -u ec2-user pm2 save
      Tags:
        - Key: Name
          Value: !Sub ${EnvironmentName}-Frontend-Instance-2

  FrontendInstance3:
    Type: AWS::EC2::Instance
    Properties:
      LaunchTemplate:
        LaunchTemplateId: !Ref FrontendLaunchTemplate
        Version: !GetAtt FrontendLaunchTemplate.LatestVersionNumber
      SubnetId: !ImportValue 
        Fn::Sub: "${EnvironmentName}-Frontend-Public-Subnet-3-ID"
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash -xe
          # Configurar variables de entorno específicas para instancia 3
          cd /home/ec2-user/Frontend
          
          # Obtener el DNS del NLB3 desde SSM Parameter Store
          NLB3_DNS=$(aws ssm get-parameter --name /${EnvironmentName}/network/nlb3-dns --region ${AWS::Region} --query "Parameter.Value" --output text)
          
          cat > .env << EOL
          PUBLIC_API_URL=http://$NLB3_DNS:80/api/
          PORT=4321
          EOL
          
          # Construir la aplicación
          sudo -u ec2-user npm run build
          
          # Iniciar con PM2 como usuario ec2-user
          sudo -u ec2-user pm2 start npm --name "frontend" -- run start
          sudo -u ec2-user pm2 save
      Tags:
        - Key: Name
          Value: !Sub ${EnvironmentName}-Frontend-Instance-3

  # Registrar instancias en el Target Group existente
  FrontendTargetGroupAttachment1:
    Type: Custom::TargetGroupAttachment
    Properties:
      ServiceToken: !GetAtt TargetGroupAttachmentLambda.Arn
      TargetGroupArn: !ImportValue 
        Fn::Sub: "${EnvironmentName}-Frontend-TG-ARN"
      TargetId: !Ref FrontendInstance1
      Port: 80

  FrontendTargetGroupAttachment2:
    Type: Custom::TargetGroupAttachment
    Properties:
      ServiceToken: !GetAtt TargetGroupAttachmentLambda.Arn
      TargetGroupArn: !ImportValue 
        Fn::Sub: "${EnvironmentName}-Frontend-TG-ARN"
      TargetId: !Ref FrontendInstance2
      Port: 80

  FrontendTargetGroupAttachment3:
    Type: Custom::TargetGroupAttachment
    Properties:
      ServiceToken: !GetAtt TargetGroupAttachmentLambda.Arn
      TargetGroupArn: !ImportValue 
        Fn::Sub: "${EnvironmentName}-Frontend-TG-ARN"
      TargetId: !Ref FrontendInstance3
      Port: 80

  # Lambda para registrar instancias en el target group
  TargetGroupAttachmentLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ElasticLoadBalancingAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - elasticloadbalancing:RegisterTargets
                  - elasticloadbalancing:DeregisterTargets
                  - elasticloadbalancing:DescribeTargetHealth
                Resource: '*'

  TargetGroupAttachmentLambda:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Role: !GetAtt TargetGroupAttachmentLambdaRole.Arn
      Runtime: nodejs16.x
      Timeout: 30
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const elbv2 = new AWS.ELBv2();
          const { CLOUDFORMATION_RESPONSE_URL, REGION } = process.env;
          
          exports.handler = async (event, context) => {
            console.log('Event: ', JSON.stringify(event, null, 2));
            
            // Inicializar respuesta
            let responseStatus = 'SUCCESS';
            let responseData = {};
            
            try {
              if (event.RequestType === 'Create' || event.RequestType === 'Update') {
                // Registrar target en el grupo
                const registerParams = {
                  TargetGroupArn: event.ResourceProperties.TargetGroupArn,
                  Targets: [
                    {
                      Id: event.ResourceProperties.TargetId,
                      Port: parseInt(event.ResourceProperties.Port, 10)
                    }
                  ]
                };
                
                await elbv2.registerTargets(registerParams).promise();
                responseData = { TargetId: event.ResourceProperties.TargetId };
              } else if (event.RequestType === 'Delete') {
                // Desregistrar target del grupo
                const deregisterParams = {
                  TargetGroupArn: event.ResourceProperties.TargetGroupArn,
                  Targets: [
                    {
                      Id: event.ResourceProperties.TargetId,
                      Port: parseInt(event.ResourceProperties.Port, 10)
                    }
                  ]
                };
                
                await elbv2.deregisterTargets(deregisterParams).promise();
              }
            } catch (error) {
              console.error('Error: ', error);
              responseStatus = 'FAILED';
              responseData = { Error: error.message };
            }
            
            // Enviar respuesta a CloudFormation
            await sendResponse(event, context.logStreamName, responseStatus, responseData);
          };
          
          async function sendResponse(event, logStreamName, responseStatus, responseData) {
            const responseBody = JSON.stringify({
              Status: responseStatus,
              Reason: `See the details in CloudWatch Log Stream: ${logStreamName}`,
              PhysicalResourceId: event.ResourceProperties.TargetId || event.LogicalResourceId,
              StackId: event.StackId,
              RequestId: event.RequestId,
              LogicalResourceId: event.LogicalResourceId,
              Data: responseData
            });
            
            console.log('Response body: ', responseBody);
            
            const https = require('https');
            const url = require('url');
            
            const parsedUrl = url.parse(event.ResponseURL);
            const options = {
              hostname: parsedUrl.hostname,
              port: 443,
              path: parsedUrl.path,
              method: 'PUT',
              headers: {
                'content-type': '',
                'content-length': responseBody.length
              }
            };
            
            return new Promise((resolve, reject) => {
              const request = https.request(options, (response) => {
                console.log(`Status code: ${response.statusCode}`);
                console.log(`Status message: ${response.statusMessage}`);
                resolve();
              });
              
              request.on('error', (error) => {
                console.log(`Send response error: ${error}`);
                reject(error);
              });
              
              request.write(responseBody);
              request.end();
            });
          }

Outputs:
  FrontendInstance1Id:
    Description: ID de la instancia Frontend 1
    Value: !Ref FrontendInstance1
    Export:
      Name: !Sub "${EnvironmentName}-Frontend-Instance-1-ID"

  FrontendInstance2Id:
    Description: ID de la instancia Frontend 2
    Value: !Ref FrontendInstance2
    Export:
      Name: !Sub "${EnvironmentName}-Frontend-Instance-2-ID"

  FrontendInstance3Id:
    Description: ID de la instancia Frontend 3
    Value: !Ref FrontendInstance3
    Export:
      Name: !Sub "${EnvironmentName}-Frontend-Instance-3-ID"

  FrontendLaunchTemplateId:
    Description: ID de la Launch Template del Frontend
    Value: !Ref FrontendLaunchTemplate
    Export:
      Name: !Sub "${EnvironmentName}-Frontend-LaunchTemplate-ID" 